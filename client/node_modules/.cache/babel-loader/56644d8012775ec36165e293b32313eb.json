{"ast":null,"code":"var _jsxFileName = \"E:\\\\000gitRepositorios\\\\WorkCodeForge\\\\client\\\\src\\\\components\\\\video\\\\video.js\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport io from 'socket.io-client';\nimport Peer from 'simple-peer';\nimport styled from 'styled-components';\nimport { useDispatch } from 'react-redux'; // import { JOIN_VIDEO } from './actions'; // <- Você deve importar isso corretamente\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Container = styled.div`\n  padding: 30px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n`;\n_c = Container;\nconst StyledVideo = styled.video`\n  height: 200px;\n  width: 300px;\n  margin: 10px;\n`;\n_c2 = StyledVideo;\nconst ErrorMessage = styled.div`\n  color: red;\n  padding: 20px;\n  text-align: center;\n  border: 1px solid red;\n  border-radius: 5px;\n  margin: 10px;\n`;\n_c3 = ErrorMessage;\n\nfunction Video({\n  peer\n}) {\n  _s();\n\n  const ref = useRef();\n  useEffect(() => {\n    peer.on('stream', stream => {\n      ref.current.srcObject = stream;\n    });\n  }, [peer]);\n  return /*#__PURE__*/_jsxDEV(StyledVideo, {\n    playsInline: true,\n    autoPlay: true,\n    ref: ref\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 39,\n    columnNumber: 10\n  }, this);\n}\n\n_s(Video, \"8uVE59eA/r6b92xF80p7sH8rXLk=\");\n\n_c4 = Video;\n\nfunction VideoContainer() {\n  _s2();\n\n  const [peers, setPeers] = useState([]);\n  const [error, setError] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const userVideo = useRef();\n  const dispatch = useDispatch(); // Função para verificar se a API está disponível\n\n  const checkMediaDevicesSupport = () => {\n    if (!navigator.mediaDevices) {\n      return false;\n    }\n\n    if (!navigator.mediaDevices.getUserMedia) {\n      return false;\n    }\n\n    return true;\n  }; // Função para criar um stream de teste (mock)\n\n\n  const createMockStream = () => {\n    // Cria um canvas para simular vídeo\n    const canvas = document.createElement('canvas');\n    canvas.width = 640;\n    canvas.height = 480;\n    const ctx = canvas.getContext('2d'); // Desenha um fundo colorido com texto\n\n    ctx.fillStyle = '#4CAF50';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.font = '30px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('TESTE - Video Mock', canvas.width / 2, canvas.height / 2);\n    ctx.fillText('Ambiente de Desenvolvimento', canvas.width / 2, canvas.height / 2 + 40); // Converte canvas para stream\n\n    const stream = canvas.captureStream(30); // 30 FPS\n\n    return stream;\n  }; // Função para obter o stream de mídia\n\n\n  const getMediaStream = async () => {\n    try {\n      setIsLoading(true);\n      setError(null); // Verificar se a API está disponível\n\n      if (!checkMediaDevicesSupport()) {\n        console.warn('API de mídia não suportada - usando mock para teste');\n        const mockStream = createMockStream();\n\n        if (userVideo.current) {\n          userVideo.current.srcObject = mockStream;\n        } // dispatch(JOIN_VIDEO()); // Descomente se estiver definida\n\n\n        return;\n      } // Em ambiente de teste, tenta primeiro getUserMedia, se falhar usa mock\n\n\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: true,\n          audio: true\n        });\n\n        if (userVideo.current) {\n          userVideo.current.srcObject = stream;\n        } // dispatch(JOIN_VIDEO()); // Descomente se estiver definida\n\n      } catch (mediaError) {\n        console.warn('Erro ao acessar mídia real, usando mock:', mediaError); // Se falhar, usa stream mock para testes\n\n        const mockStream = createMockStream();\n\n        if (userVideo.current) {\n          userVideo.current.srcObject = mockStream;\n        } // dispatch(JOIN_VIDEO()); // Descomente se estiver definida\n\n      }\n    } catch (err) {\n      console.error('Erro geral:', err); // Mensagens de erro mais específicas\n\n      let errorMessage = 'Erro ao acessar câmera e microfone';\n\n      if (err.name === 'NotAllowedError') {\n        errorMessage = 'Acesso à câmera e microfone negado. Permita o acesso nas configurações do navegador.';\n      } else if (err.name === 'NotFoundError') {\n        errorMessage = 'Câmera ou microfone não encontrados.';\n      } else if (err.name === 'NotSupportedError') {\n        errorMessage = 'Câmera ou microfone não suportados neste navegador.';\n      }\n\n      setError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    getMediaStream(); // Cleanup function para parar o stream quando o componente for desmontado\n\n    return () => {\n      if (userVideo.current && userVideo.current.srcObject) {\n        const stream = userVideo.current.srcObject;\n        const tracks = stream.getTracks();\n        tracks.forEach(track => track.stop());\n      }\n    };\n  }, []); // Função para tentar novamente\n\n  const handleRetry = () => {\n    getMediaStream();\n  };\n\n  if (isLoading) {\n    return /*#__PURE__*/_jsxDEV(Container, {\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Carregando acesso \\xE0 c\\xE2mera e microfone...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 171,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 7\n    }, this);\n  }\n\n  if (error) {\n    return /*#__PURE__*/_jsxDEV(Container, {\n      children: /*#__PURE__*/_jsxDEV(ErrorMessage, {\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          children: \"Erro de M\\xEDdia\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 180,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: error\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 181,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: handleRetry,\n          children: \"Tentar Novamente\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 182,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 179,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 178,\n      columnNumber: 7\n    }, this);\n  }\n\n  return /*#__PURE__*/_jsxDEV(Container, {\n    children: [/*#__PURE__*/_jsxDEV(StyledVideo, {\n      muted: true,\n      ref: userVideo,\n      autoPlay: true,\n      playsInline: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 190,\n      columnNumber: 7\n    }, this), peers.map((peer, index) => /*#__PURE__*/_jsxDEV(Video, {\n      peer: peer\n    }, index, false, {\n      fileName: _jsxFileName,\n      lineNumber: 192,\n      columnNumber: 9\n    }, this))]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 189,\n    columnNumber: 5\n  }, this);\n}\n\n_s2(VideoContainer, \"XeUyphAQMd0TtFyrqU9UY8+K+2g=\", false, function () {\n  return [useDispatch];\n});\n\n_c5 = VideoContainer;\nexport default VideoContainer;\n\nvar _c, _c2, _c3, _c4, _c5;\n\n$RefreshReg$(_c, \"Container\");\n$RefreshReg$(_c2, \"StyledVideo\");\n$RefreshReg$(_c3, \"ErrorMessage\");\n$RefreshReg$(_c4, \"Video\");\n$RefreshReg$(_c5, \"VideoContainer\");","map":{"version":3,"sources":["E:/000gitRepositorios/WorkCodeForge/client/src/components/video/video.js"],"names":["React","useEffect","useRef","useState","io","Peer","styled","useDispatch","Container","div","StyledVideo","video","ErrorMessage","Video","peer","ref","on","stream","current","srcObject","VideoContainer","peers","setPeers","error","setError","isLoading","setIsLoading","userVideo","dispatch","checkMediaDevicesSupport","navigator","mediaDevices","getUserMedia","createMockStream","canvas","document","createElement","width","height","ctx","getContext","fillStyle","fillRect","font","textAlign","fillText","captureStream","getMediaStream","console","warn","mockStream","audio","mediaError","err","errorMessage","name","tracks","getTracks","forEach","track","stop","handleRetry","map","index"],"mappings":"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","sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport io from 'socket.io-client';\r\nimport Peer from 'simple-peer';\r\nimport styled from 'styled-components';\r\nimport { useDispatch } from 'react-redux';\r\n// import { JOIN_VIDEO } from './actions'; // <- Você deve importar isso corretamente\r\n\r\nconst Container = styled.div`\r\n  padding: 30px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n`;\r\n\r\nconst StyledVideo = styled.video`\r\n  height: 200px;\r\n  width: 300px;\r\n  margin: 10px;\r\n`;\r\n\r\nconst ErrorMessage = styled.div`\r\n  color: red;\r\n  padding: 20px;\r\n  text-align: center;\r\n  border: 1px solid red;\r\n  border-radius: 5px;\r\n  margin: 10px;\r\n`;\r\n\r\nfunction Video({ peer }) {\r\n  const ref = useRef();\r\n\r\n  useEffect(() => {\r\n    peer.on('stream', (stream) => {\r\n      ref.current.srcObject = stream;\r\n    });\r\n  }, [peer]);\r\n\r\n  return <StyledVideo playsInline autoPlay ref={ref} />;\r\n}\r\n\r\nfunction VideoContainer() {\r\n  const [peers, setPeers] = useState([]);\r\n  const [error, setError] = useState(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const userVideo = useRef();\r\n  const dispatch = useDispatch();\r\n\r\n  // Função para verificar se a API está disponível\r\n  const checkMediaDevicesSupport = () => {\r\n    if (!navigator.mediaDevices) {\r\n      return false;\r\n    }\r\n    \r\n    if (!navigator.mediaDevices.getUserMedia) {\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  };\r\n\r\n  // Função para criar um stream de teste (mock)\r\n  const createMockStream = () => {\r\n    // Cria um canvas para simular vídeo\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = 640;\r\n    canvas.height = 480;\r\n    const ctx = canvas.getContext('2d');\r\n    \r\n    // Desenha um fundo colorido com texto\r\n    ctx.fillStyle = '#4CAF50';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n    ctx.fillStyle = 'white';\r\n    ctx.font = '30px Arial';\r\n    ctx.textAlign = 'center';\r\n    ctx.fillText('TESTE - Video Mock', canvas.width / 2, canvas.height / 2);\r\n    ctx.fillText('Ambiente de Desenvolvimento', canvas.width / 2, canvas.height / 2 + 40);\r\n    \r\n    // Converte canvas para stream\r\n    const stream = canvas.captureStream(30); // 30 FPS\r\n    \r\n    return stream;\r\n  };\r\n\r\n  // Função para obter o stream de mídia\r\n  const getMediaStream = async () => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n\r\n      // Verificar se a API está disponível\r\n      if (!checkMediaDevicesSupport()) {\r\n        console.warn('API de mídia não suportada - usando mock para teste');\r\n        const mockStream = createMockStream();\r\n        \r\n        if (userVideo.current) {\r\n          userVideo.current.srcObject = mockStream;\r\n        }\r\n        \r\n        // dispatch(JOIN_VIDEO()); // Descomente se estiver definida\r\n        return;\r\n      }\r\n\r\n      // Em ambiente de teste, tenta primeiro getUserMedia, se falhar usa mock\r\n      try {\r\n        const stream = await navigator.mediaDevices.getUserMedia({ \r\n          video: true, \r\n          audio: true \r\n        });\r\n        \r\n        if (userVideo.current) {\r\n          userVideo.current.srcObject = stream;\r\n        }\r\n        \r\n        // dispatch(JOIN_VIDEO()); // Descomente se estiver definida\r\n        \r\n      } catch (mediaError) {\r\n        console.warn('Erro ao acessar mídia real, usando mock:', mediaError);\r\n        \r\n        // Se falhar, usa stream mock para testes\r\n        const mockStream = createMockStream();\r\n        \r\n        if (userVideo.current) {\r\n          userVideo.current.srcObject = mockStream;\r\n        }\r\n        \r\n        // dispatch(JOIN_VIDEO()); // Descomente se estiver definida\r\n      }\r\n      \r\n    } catch (err) {\r\n      console.error('Erro geral:', err);\r\n      \r\n      // Mensagens de erro mais específicas\r\n      let errorMessage = 'Erro ao acessar câmera e microfone';\r\n      \r\n      if (err.name === 'NotAllowedError') {\r\n        errorMessage = 'Acesso à câmera e microfone negado. Permita o acesso nas configurações do navegador.';\r\n      } else if (err.name === 'NotFoundError') {\r\n        errorMessage = 'Câmera ou microfone não encontrados.';\r\n      } else if (err.name === 'NotSupportedError') {\r\n        errorMessage = 'Câmera ou microfone não suportados neste navegador.';\r\n      }\r\n      \r\n      setError(errorMessage);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    getMediaStream();\r\n    \r\n    // Cleanup function para parar o stream quando o componente for desmontado\r\n    return () => {\r\n      if (userVideo.current && userVideo.current.srcObject) {\r\n        const stream = userVideo.current.srcObject;\r\n        const tracks = stream.getTracks();\r\n        tracks.forEach(track => track.stop());\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Função para tentar novamente\r\n  const handleRetry = () => {\r\n    getMediaStream();\r\n  };\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <Container>\r\n        <div>Carregando acesso à câmera e microfone...</div>\r\n      </Container>\r\n    );\r\n  }\r\n\r\n  if (error) {\r\n    return (\r\n      <Container>\r\n        <ErrorMessage>\r\n          <h3>Erro de Mídia</h3>\r\n          <p>{error}</p>\r\n          <button onClick={handleRetry}>Tentar Novamente</button>\r\n        </ErrorMessage>\r\n      </Container>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <Container>\r\n      <StyledVideo muted ref={userVideo} autoPlay playsInline />\r\n      {peers.map((peer, index) => (\r\n        <Video key={index} peer={peer} />\r\n      ))}\r\n    </Container>\r\n  );\r\n}\r\n\r\nexport default VideoContainer;"]},"metadata":{},"sourceType":"module"}