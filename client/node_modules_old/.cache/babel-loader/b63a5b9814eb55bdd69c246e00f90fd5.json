{"ast":null,"code":"import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Vector2, Line3, MathUtils, Matrix4, Mesh, Vector4 } from 'three';\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n}; // support multiple method names for backwards threejs compatibility\n\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _box$1 = new THREE$2.Box3();\n\nconst _vector = new THREE$2.Vector3();\n\nclass LineSegmentsGeometry extends THREE$2.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.type = 'LineSegmentsGeometry';\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this[setAttributeFn$1]('position', new THREE$2.Float32BufferAttribute(positions, 3));\n    this[setAttributeFn$1]('uv', new THREE$2.Float32BufferAttribute(uvs, 2));\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  setPositions(array) {\n    let lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    const instanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn$1]('instanceStart', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn$1]('instanceEnd', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n\n  setColors(array) {\n    let colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    const instanceColorBuffer = new THREE$2.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn$1]('instanceColorStart', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn$1]('instanceColorEnd', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new THREE$2.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new THREE$2.Box3();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n\n      _box$1.setFromBufferAttribute(end);\n\n      this.boundingBox.union(_box$1);\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new THREE$2.Sphere();\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n\n        _vector.fromBufferAttribute(end, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n\n  toJSON() {// todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n}\n\nLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  worldUnits: {\n    value: 1\n  },\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new THREE$1.Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  gapSize: {\n    value: 1\n  } // todo FIX - maybe change to totalSize\n\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\tworldStart = start.xyz;\n\t\t\tworldEnd = end.xyz;\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segements overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends THREE$1.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n      uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n      vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n      fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      worldUnits: {\n        enumerable: true,\n        get: function () {\n          return 'WORLD_UNITS' in this.defines;\n        },\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = '';\n          } else {\n            delete this.defines.WORLD_UNITS;\n          }\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value === true) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value === true) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nLineMaterial.prototype.isLineMaterial = true;\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4\n};\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _start = new THREE.Vector3();\n\nconst _end = new THREE.Vector3();\n\nconst _start4 = new THREE.Vector4();\n\nconst _end4 = new THREE.Vector4();\n\nconst _ssOrigin = new THREE.Vector4();\n\nconst _ssOrigin3 = new THREE.Vector3();\n\nconst _mvMatrix = new THREE.Matrix4();\n\nconst _line = new THREE.Line3();\n\nconst _closestPoint = new THREE.Vector3();\n\nconst _box = new THREE.Box3();\n\nconst _sphere = new THREE.Sphere();\n\nconst _clipToWorldVector = new THREE.Vector4();\n\nclass LineSegments2 extends THREE.Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'LineSegments2';\n  } // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry[setAttributeFn]('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry[setAttributeFn]('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    const ray = raycaster.ray;\n    const camera = raycaster.camera;\n    const projectionMatrix = camera.projectionMatrix;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    const resolution = material.resolution;\n    const lineWidth = material.linewidth + threshold;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n    const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n    // width in clip space\n\n    const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n    // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n\n    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _sphere.radius += sphereMargin;\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) {\n      return;\n    } //\n    // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n\n    const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _box.max.x += boxMargin;\n    _box.max.y += boxMargin;\n    _box.max.z += boxMargin;\n    _box.min.x -= boxMargin;\n    _box.min.y -= boxMargin;\n    _box.min.z -= boxMargin;\n\n    if (raycaster.ray.intersectsBox(_box) === false) {\n      return;\n    } //\n    // pick a point 1 unit out along the ray to avoid the ray origin\n    // sitting at the camera origin which will cause \"w\" to be 0 when\n    // applying the projection matrix.\n\n\n    ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n    _ssOrigin.w = 1;\n\n    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n    _ssOrigin.applyMatrix4(projectionMatrix);\n\n    _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n    _ssOrigin.x *= resolution.x / 2;\n    _ssOrigin.y *= resolution.y / 2;\n    _ssOrigin.z = 0;\n\n    _ssOrigin3.copy(_ssOrigin);\n\n    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n    for (let i = 0, l = instanceStart.count; i < l; i++) {\n      _start4.fromBufferAttribute(instanceStart, i);\n\n      _end4.fromBufferAttribute(instanceEnd, i);\n\n      _start4.w = 1;\n      _end4.w = 1; // camera space\n\n      _start4.applyMatrix4(_mvMatrix);\n\n      _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n      var isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n      if (isBehindCameraNear) {\n        continue;\n      } // trim the segment if it extends behind camera near\n\n\n      if (_start4.z > near) {\n        const deltaDist = _start4.z - _end4.z;\n        const t = (_start4.z - near) / deltaDist;\n\n        _start4.lerp(_end4, t);\n      } else if (_end4.z > near) {\n        const deltaDist = _end4.z - _start4.z;\n        const t = (_end4.z - near) / deltaDist;\n\n        _end4.lerp(_start4, t);\n      } // clip space\n\n\n      _start4.applyMatrix4(projectionMatrix);\n\n      _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n      _start4.multiplyScalar(1 / _start4.w);\n\n      _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n      _start4.x *= resolution.x / 2;\n      _start4.y *= resolution.y / 2;\n      _end4.x *= resolution.x / 2;\n      _end4.y *= resolution.y / 2; // create 2d segment\n\n      _line.start.copy(_start4);\n\n      _line.start.z = 0;\n\n      _line.end.copy(_end4);\n\n      _line.end.z = 0; // get closest point on ray to segment\n\n      const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n      _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n      const zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\n      const isInClipSpace = zPos >= -1 && zPos <= 1;\n      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n\n      if (isInClipSpace && isInside) {\n        _line.start.fromBufferAttribute(instanceStart, i);\n\n        _line.end.fromBufferAttribute(instanceEnd, i);\n\n        _line.start.applyMatrix4(matrixWorld);\n\n        _line.end.applyMatrix4(matrixWorld);\n\n        const pointOnLine = new THREE.Vector3();\n        const point = new THREE.Vector3();\n        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n        intersects.push({\n          point: point,\n          pointOnLine: pointOnLine,\n          distance: ray.origin.distanceTo(point),\n          object: this,\n          face: null,\n          faceIndex: i,\n          uv: null,\n          uv2: null\n        });\n      }\n    }\n  }\n\n}\n\nLineSegments2.prototype.LineSegments2 = true;\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.type = 'LineGeometry';\n  }\n\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    super.setPositions(points);\n    return this;\n  }\n\n  setColors(array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n\n    super.setColors(colors);\n    return this;\n  }\n\n  fromLine(line) {\n    var geometry = line.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n}\n\nLineGeometry.prototype.isLineGeometry = true;\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'Line2';\n  }\n\n}\n\nLine2.prototype.isLine2 = true;\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };","map":{"version":3,"sources":["C:/00001_Arquivos/0002_gitHub/WorkLand_old1/client/node_modules/three-fatline/dist/three-fatline.module.js"],"names":["Box3","BufferGeometry","Float32BufferAttribute","InstancedBufferGeometry","InstancedInterleavedBuffer","InterleavedBufferAttribute","Sphere","Vector3","WireframeGeometry","ShaderLib","ShaderMaterial","UniformsLib","UniformsUtils","Vector2","Line3","MathUtils","Matrix4","Mesh","Vector4","THREE$2","window","THREE","setAttributeFn$1","setAttribute","_box$1","_vector","LineSegmentsGeometry","constructor","type","positions","uvs","index","setIndex","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","undefined","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","setColors","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","fromLineSegments","isGeometry","console","error","isBufferGeometry","setFromBufferAttribute","union","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","toJSON","applyMatrix","warn","prototype","isLineSegmentsGeometry","THREE$1","line","worldUnits","value","linewidth","resolution","dashScale","dashSize","gapSize","uniforms","merge","common","fog","vertexShader","fragmentShader","LineMaterial","parameters","clone","clipping","Object","defineProperties","color","enumerable","get","diffuse","set","defines","WORLD_UNITS","dashed","Boolean","USE_DASH","dashOffset","opacity","copy","alphaToCoverage","ALPHA_TO_COVERAGE","extensions","derivatives","setValues","isLineMaterial","setAttributeFn","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","LineSegments2","material","random","computeLineDistances","lineDistances","j","l","distanceTo","instanceDistanceBuffer","raycast","raycaster","intersects","camera","threshold","params","Line2","ray","projectionMatrix","matrixWorld","lineWidth","near","ssMaxWidth","width","height","distanceToSphere","distanceToPoint","origin","multiplyScalar","w","projectionMatrixInverse","sphereMargin","abs","intersectsSphere","distanceToBox","boxMargin","x","y","z","min","intersectsBox","at","matrixWorldInverse","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","object","face","faceIndex","uv","uv2","LineGeometry","length","points","fromLine","isLineGeometry","isLine2"],"mappings":"AAAA,SAASA,IAAT,EAAeC,cAAf,EAA+BC,sBAA/B,EAAuDC,uBAAvD,EAAgFC,0BAAhF,EAA4GC,0BAA5G,EAAwIC,MAAxI,EAAgJC,OAAhJ,EAAyJC,iBAAzJ,EAA4KC,SAA5K,EAAuLC,cAAvL,EAAuMC,WAAvM,EAAoNC,aAApN,EAAmOC,OAAnO,EAA4OC,KAA5O,EAAmPC,SAAnP,EAA8PC,OAA9P,EAAuQC,IAAvQ,EAA6QC,OAA7Q,QAA4R,OAA5R;AAEA,MAAMC,OAAO,GAAGC,MAAM,CAACC,KAAP,GAAeD,MAAM,CAACC,KAAtB,CAA4B;AAA5B,EACd;AACArB,EAAAA,IADA;AAEAC,EAAAA,cAFA;AAGAC,EAAAA,sBAHA;AAIAC,EAAAA,uBAJA;AAKAC,EAAAA,0BALA;AAMAC,EAAAA,0BANA;AAOAC,EAAAA,MAPA;AAQAC,EAAAA,OARA;AASAC,EAAAA;AATA,CADF,C,CAWG;;AAEH,IAAIc,gBAAgB,GAAG,IAAIH,OAAO,CAAClB,cAAZ,GAA6BsB,YAA7B,GAA4C,cAA5C,GAA6D,cAApF;;AAEA,MAAMC,MAAM,GAAG,IAAIL,OAAO,CAACnB,IAAZ,EAAf;;AAEA,MAAMyB,OAAO,GAAG,IAAIN,OAAO,CAACZ,OAAZ,EAAhB;;AAEA,MAAMmB,oBAAN,SAAmCP,OAAO,CAAChB,uBAA3C,CAAmE;AACjEwB,EAAAA,WAAW,GAAG;AACZ;AACA,SAAKC,IAAL,GAAY,sBAAZ;AACA,UAAMC,SAAS,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAAC,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAApC,EAAuC,CAAC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,EAAiD,CAAjD,EAAoD,CAApD,EAAuD,CAAvD,EAA0D,CAAC,CAA3D,EAA8D,CAAC,CAA/D,EAAkE,CAAlE,EAAqE,CAArE,EAAwE,CAAC,CAAzE,EAA4E,CAA5E,CAAlB;AACA,UAAMC,GAAG,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAX,EAAc,CAAC,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAAC,CAA5B,EAA+B,CAAC,CAAhC,EAAmC,CAAnC,EAAsC,CAAC,CAAvC,EAA0C,CAAC,CAA3C,EAA8C,CAAC,CAA/C,EAAkD,CAAlD,EAAqD,CAAC,CAAtD,CAAZ;AACA,UAAMC,KAAK,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,EAAiD,CAAjD,EAAoD,CAApD,CAAd;AACA,SAAKC,QAAL,CAAcD,KAAd;AACA,SAAKT,gBAAL,EAAuB,UAAvB,EAAmC,IAAIH,OAAO,CAACjB,sBAAZ,CAAmC2B,SAAnC,EAA8C,CAA9C,CAAnC;AACA,SAAKP,gBAAL,EAAuB,IAAvB,EAA6B,IAAIH,OAAO,CAACjB,sBAAZ,CAAmC4B,GAAnC,EAAwC,CAAxC,CAA7B;AACD;;AAEDG,EAAAA,YAAY,CAACC,MAAD,EAAS;AACnB,UAAMC,KAAK,GAAG,KAAKC,UAAL,CAAgBC,aAA9B;AACA,UAAMC,GAAG,GAAG,KAAKF,UAAL,CAAgBG,WAA5B;;AAEA,QAAIJ,KAAK,KAAKK,SAAd,EAAyB;AACvBL,MAAAA,KAAK,CAACF,YAAN,CAAmBC,MAAnB;AACAI,MAAAA,GAAG,CAACL,YAAJ,CAAiBC,MAAjB;AACAC,MAAAA,KAAK,CAACM,WAAN,GAAoB,IAApB;AACD;;AAED,QAAI,KAAKC,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,WAAKC,kBAAL;AACD;;AAED,QAAI,KAAKC,cAAL,KAAwB,IAA5B,EAAkC;AAChC,WAAKC,qBAAL;AACD;;AAED,WAAO,IAAP;AACD;;AAEDC,EAAAA,YAAY,CAACC,KAAD,EAAQ;AAClB,QAAIC,YAAJ;;AAEA,QAAID,KAAK,YAAYE,YAArB,EAAmC;AACjCD,MAAAA,YAAY,GAAGD,KAAf;AACD,KAFD,MAEO,IAAIG,KAAK,CAACC,OAAN,CAAcJ,KAAd,CAAJ,EAA0B;AAC/BC,MAAAA,YAAY,GAAG,IAAIC,YAAJ,CAAiBF,KAAjB,CAAf;AACD;;AAED,UAAMK,cAAc,GAAG,IAAIjC,OAAO,CAACf,0BAAZ,CAAuC4C,YAAvC,EAAqD,CAArD,EAAwD,CAAxD,CAAvB,CATkB,CASiE;;AAEnF,SAAK1B,gBAAL,EAAuB,eAAvB,EAAwC,IAAIH,OAAO,CAACd,0BAAZ,CAAuC+C,cAAvC,EAAuD,CAAvD,EAA0D,CAA1D,CAAxC,EAXkB,CAWqF;;AAEvG,SAAK9B,gBAAL,EAAuB,aAAvB,EAAsC,IAAIH,OAAO,CAACd,0BAAZ,CAAuC+C,cAAvC,EAAuD,CAAvD,EAA0D,CAA1D,CAAtC,EAbkB,CAamF;AACrG;;AAEA,SAAKT,kBAAL;AACA,SAAKE,qBAAL;AACA,WAAO,IAAP;AACD;;AAEDQ,EAAAA,SAAS,CAACN,KAAD,EAAQ;AACf,QAAIO,MAAJ;;AAEA,QAAIP,KAAK,YAAYE,YAArB,EAAmC;AACjCK,MAAAA,MAAM,GAAGP,KAAT;AACD,KAFD,MAEO,IAAIG,KAAK,CAACC,OAAN,CAAcJ,KAAd,CAAJ,EAA0B;AAC/BO,MAAAA,MAAM,GAAG,IAAIL,YAAJ,CAAiBF,KAAjB,CAAT;AACD;;AAED,UAAMQ,mBAAmB,GAAG,IAAIpC,OAAO,CAACf,0BAAZ,CAAuCkD,MAAvC,EAA+C,CAA/C,EAAkD,CAAlD,CAA5B,CATe,CASmE;;AAElF,SAAKhC,gBAAL,EAAuB,oBAAvB,EAA6C,IAAIH,OAAO,CAACd,0BAAZ,CAAuCkD,mBAAvC,EAA4D,CAA5D,EAA+D,CAA/D,CAA7C,EAXe,CAWkG;;AAEjH,SAAKjC,gBAAL,EAAuB,kBAAvB,EAA2C,IAAIH,OAAO,CAACd,0BAAZ,CAAuCkD,mBAAvC,EAA4D,CAA5D,EAA+D,CAA/D,CAA3C,EAbe,CAagG;;AAE/G,WAAO,IAAP;AACD;;AAEDC,EAAAA,qBAAqB,CAACC,QAAD,EAAW;AAC9B,SAAKX,YAAL,CAAkBW,QAAQ,CAACrB,UAAT,CAAoBsB,QAApB,CAA6BX,KAA/C;AACA,WAAO,IAAP;AACD;;AAEDY,EAAAA,iBAAiB,CAACF,QAAD,EAAW;AAC1B,SAAKX,YAAL,CAAkBW,QAAQ,CAACrB,UAAT,CAAoBsB,QAApB,CAA6BX,KAA/C;AACA,WAAO,IAAP;AACD;;AAEDa,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACb,SAAKL,qBAAL,CAA2B,IAAIrC,OAAO,CAACX,iBAAZ,CAA8BqD,IAAI,CAACJ,QAAnC,CAA3B,EADa,CAC6D;;AAE1E,WAAO,IAAP;AACD;;AAEDK,EAAAA,gBAAgB,CAACd,YAAD,EAAe;AAC7B,UAAMS,QAAQ,GAAGT,YAAY,CAACS,QAA9B;;AAEA,QAAIA,QAAQ,CAACM,UAAb,EAAyB;AACvBC,MAAAA,OAAO,CAACC,KAAR,CAAc,qFAAd;AACA;AACD,KAHD,MAGO,IAAIR,QAAQ,CAACS,gBAAb,EAA+B;AACpC,WAAKpB,YAAL,CAAkBW,QAAQ,CAACrB,UAAT,CAAoBsB,QAApB,CAA6BX,KAA/C,EADoC,CACmB;AACxD,KAR4B,CAQ3B;;;AAGF,WAAO,IAAP;AACD;;AAEDJ,EAAAA,kBAAkB,GAAG;AACnB,QAAI,KAAKD,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,WAAKA,WAAL,GAAmB,IAAIvB,OAAO,CAACnB,IAAZ,EAAnB;AACD;;AAED,UAAMmC,KAAK,GAAG,KAAKC,UAAL,CAAgBC,aAA9B;AACA,UAAMC,GAAG,GAAG,KAAKF,UAAL,CAAgBG,WAA5B;;AAEA,QAAIJ,KAAK,KAAKK,SAAV,IAAuBF,GAAG,KAAKE,SAAnC,EAA8C;AAC5C,WAAKE,WAAL,CAAiByB,sBAAjB,CAAwChC,KAAxC;;AAEAX,MAAAA,MAAM,CAAC2C,sBAAP,CAA8B7B,GAA9B;;AAEA,WAAKI,WAAL,CAAiB0B,KAAjB,CAAuB5C,MAAvB;AACD;AACF;;AAEDqB,EAAAA,qBAAqB,GAAG;AACtB,QAAI,KAAKD,cAAL,KAAwB,IAA5B,EAAkC;AAChC,WAAKA,cAAL,GAAsB,IAAIzB,OAAO,CAACb,MAAZ,EAAtB;AACD;;AAED,QAAI,KAAKoC,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,WAAKC,kBAAL;AACD;;AAED,UAAMR,KAAK,GAAG,KAAKC,UAAL,CAAgBC,aAA9B;AACA,UAAMC,GAAG,GAAG,KAAKF,UAAL,CAAgBG,WAA5B;;AAEA,QAAIJ,KAAK,KAAKK,SAAV,IAAuBF,GAAG,KAAKE,SAAnC,EAA8C;AAC5C,YAAM6B,MAAM,GAAG,KAAKzB,cAAL,CAAoByB,MAAnC;AACA,WAAK3B,WAAL,CAAiB4B,SAAjB,CAA2BD,MAA3B;AACA,UAAIE,WAAW,GAAG,CAAlB;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGtC,KAAK,CAACuC,KAA3B,EAAkCF,CAAC,GAAGC,EAAtC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C/C,QAAAA,OAAO,CAACkD,mBAAR,CAA4BxC,KAA5B,EAAmCqC,CAAnC;;AAEAD,QAAAA,WAAW,GAAGK,IAAI,CAACC,GAAL,CAASN,WAAT,EAAsBF,MAAM,CAACS,iBAAP,CAAyBrD,OAAzB,CAAtB,CAAd;;AAEAA,QAAAA,OAAO,CAACkD,mBAAR,CAA4BrC,GAA5B,EAAiCkC,CAAjC;;AAEAD,QAAAA,WAAW,GAAGK,IAAI,CAACC,GAAL,CAASN,WAAT,EAAsBF,MAAM,CAACS,iBAAP,CAAyBrD,OAAzB,CAAtB,CAAd;AACD;;AAED,WAAKmB,cAAL,CAAoBmC,MAApB,GAA6BH,IAAI,CAACI,IAAL,CAAUT,WAAV,CAA7B;;AAEA,UAAIU,KAAK,CAAC,KAAKrC,cAAL,CAAoBmC,MAArB,CAAT,EAAuC;AACrCf,QAAAA,OAAO,CAACC,KAAR,CAAc,uIAAd,EAAuJ,IAAvJ;AACD;AACF;AACF;;AAEDiB,EAAAA,MAAM,GAAG,CAAC;AACT;;AAEDC,EAAAA,WAAW,CAACjD,MAAD,EAAS;AAClB8B,IAAAA,OAAO,CAACoB,IAAR,CAAa,+EAAb;AACA,WAAO,KAAKnD,YAAL,CAAkBC,MAAlB,CAAP;AACD;;AAhKgE;;AAoKnER,oBAAoB,CAAC2D,SAArB,CAA+BC,sBAA/B,GAAwD,IAAxD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,OAAO,GAAGnE,MAAM,CAACC,KAAP,GAAeD,MAAM,CAACC,KAAtB,CAA4B;AAA5B,EACd;AACAZ,EAAAA,SADA;AAEAC,EAAAA,cAFA;AAGAC,EAAAA,WAHA;AAIAC,EAAAA,aAJA;AAKAC,EAAAA;AALA,CADF;AAQA0E,OAAO,CAAC5E,WAAR,CAAoB6E,IAApB,GAA2B;AACzBC,EAAAA,UAAU,EAAE;AACVC,IAAAA,KAAK,EAAE;AADG,GADa;AAIzBC,EAAAA,SAAS,EAAE;AACTD,IAAAA,KAAK,EAAE;AADE,GAJc;AAOzBE,EAAAA,UAAU,EAAE;AACVF,IAAAA,KAAK,EAAE,IAAIH,OAAO,CAAC1E,OAAZ,CAAoB,CAApB,EAAuB,CAAvB;AADG,GAPa;AAUzBgF,EAAAA,SAAS,EAAE;AACTH,IAAAA,KAAK,EAAE;AADE,GAVc;AAazBI,EAAAA,QAAQ,EAAE;AACRJ,IAAAA,KAAK,EAAE;AADC,GAbe;AAgBzBK,EAAAA,OAAO,EAAE;AACPL,IAAAA,KAAK,EAAE;AADA,GAhBgB,CAkBvB;;AAlBuB,CAA3B;AAqBAH,OAAO,CAAC9E,SAAR,CAAkB,MAAlB,IAA4B;AAC1BuF,EAAAA,QAAQ,EAAET,OAAO,CAAC3E,aAAR,CAAsBqF,KAAtB,CAA4B,CAACV,OAAO,CAAC5E,WAAR,CAAoBuF,MAArB,EAA6BX,OAAO,CAAC5E,WAAR,CAAoBwF,GAAjD,EAAsDZ,OAAO,CAAC5E,WAAR,CAAoB6E,IAA1E,CAA5B,CADgB;AAE1BY,EAAAA,YAAY;AACZ;AACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GApN4B;AAqN1BC,EAAAA,cAAc;AACd;AACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxW4B,CAA5B;;AA2WA,MAAMC,YAAN,SAA2Bf,OAAO,CAAC7E,cAAnC,CAAkD;AAChDiB,EAAAA,WAAW,CAAC4E,UAAD,EAAa;AACtB,UAAM;AACJ3E,MAAAA,IAAI,EAAE,cADF;AAEJoE,MAAAA,QAAQ,EAAET,OAAO,CAAC3E,aAAR,CAAsB4F,KAAtB,CAA4BjB,OAAO,CAAC9E,SAAR,CAAkB,MAAlB,EAA0BuF,QAAtD,CAFN;AAGJI,MAAAA,YAAY,EAAEb,OAAO,CAAC9E,SAAR,CAAkB,MAAlB,EAA0B2F,YAHpC;AAIJC,MAAAA,cAAc,EAAEd,OAAO,CAAC9E,SAAR,CAAkB,MAAlB,EAA0B4F,cAJtC;AAKJI,MAAAA,QAAQ,EAAE,IALN,CAKW;;AALX,KAAN;AAQAC,IAAAA,MAAM,CAACC,gBAAP,CAAwB,IAAxB,EAA8B;AAC5BC,MAAAA,KAAK,EAAE;AACLC,QAAAA,UAAU,EAAE,IADP;AAELC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAO,KAAKd,QAAL,CAAce,OAAd,CAAsBrB,KAA7B;AACD,SAJI;AAKLsB,QAAAA,GAAG,EAAE,UAAUtB,KAAV,EAAiB;AACpB,eAAKM,QAAL,CAAce,OAAd,CAAsBrB,KAAtB,GAA8BA,KAA9B;AACD;AAPI,OADqB;AAU5BD,MAAAA,UAAU,EAAE;AACVoB,QAAAA,UAAU,EAAE,IADF;AAEVC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAO,iBAAiB,KAAKG,OAA7B;AACD,SAJS;AAKVD,QAAAA,GAAG,EAAE,UAAUtB,KAAV,EAAiB;AACpB,cAAIA,KAAK,KAAK,IAAd,EAAoB;AAClB,iBAAKuB,OAAL,CAAaC,WAAb,GAA2B,EAA3B;AACD,WAFD,MAEO;AACL,mBAAO,KAAKD,OAAL,CAAaC,WAApB;AACD;AACF;AAXS,OAVgB;AAuB5BvB,MAAAA,SAAS,EAAE;AACTkB,QAAAA,UAAU,EAAE,IADH;AAETC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAO,KAAKd,QAAL,CAAcL,SAAd,CAAwBD,KAA/B;AACD,SAJQ;AAKTsB,QAAAA,GAAG,EAAE,UAAUtB,KAAV,EAAiB;AACpB,eAAKM,QAAL,CAAcL,SAAd,CAAwBD,KAAxB,GAAgCA,KAAhC;AACD;AAPQ,OAvBiB;AAgC5ByB,MAAAA,MAAM,EAAE;AACNN,QAAAA,UAAU,EAAE,IADN;AAENC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAOM,OAAO,CAAC,cAAc,KAAKH,OAApB,CAAd;AACD,SAJK;;AAMND,QAAAA,GAAG,CAACtB,KAAD,EAAQ;AACT,cAAI0B,OAAO,CAAC1B,KAAD,CAAP,KAAmB0B,OAAO,CAAC,cAAc,KAAKH,OAApB,CAA9B,EAA4D;AAC1D,iBAAKxE,WAAL,GAAmB,IAAnB;AACD;;AAED,cAAIiD,KAAK,KAAK,IAAd,EAAoB;AAClB,iBAAKuB,OAAL,CAAaI,QAAb,GAAwB,EAAxB;AACD,WAFD,MAEO;AACL,mBAAO,KAAKJ,OAAL,CAAaI,QAApB;AACD;AACF;;AAhBK,OAhCoB;AAmD5BxB,MAAAA,SAAS,EAAE;AACTgB,QAAAA,UAAU,EAAE,IADH;AAETC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAO,KAAKd,QAAL,CAAcH,SAAd,CAAwBH,KAA/B;AACD,SAJQ;AAKTsB,QAAAA,GAAG,EAAE,UAAUtB,KAAV,EAAiB;AACpB,eAAKM,QAAL,CAAcH,SAAd,CAAwBH,KAAxB,GAAgCA,KAAhC;AACD;AAPQ,OAnDiB;AA4D5BI,MAAAA,QAAQ,EAAE;AACRe,QAAAA,UAAU,EAAE,IADJ;AAERC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAO,KAAKd,QAAL,CAAcF,QAAd,CAAuBJ,KAA9B;AACD,SAJO;AAKRsB,QAAAA,GAAG,EAAE,UAAUtB,KAAV,EAAiB;AACpB,eAAKM,QAAL,CAAcF,QAAd,CAAuBJ,KAAvB,GAA+BA,KAA/B;AACD;AAPO,OA5DkB;AAqE5B4B,MAAAA,UAAU,EAAE;AACVT,QAAAA,UAAU,EAAE,IADF;AAEVC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAO,KAAKd,QAAL,CAAcsB,UAAd,CAAyB5B,KAAhC;AACD,SAJS;AAKVsB,QAAAA,GAAG,EAAE,UAAUtB,KAAV,EAAiB;AACpB,eAAKM,QAAL,CAAcsB,UAAd,CAAyB5B,KAAzB,GAAiCA,KAAjC;AACD;AAPS,OArEgB;AA8E5BK,MAAAA,OAAO,EAAE;AACPc,QAAAA,UAAU,EAAE,IADL;AAEPC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAO,KAAKd,QAAL,CAAcD,OAAd,CAAsBL,KAA7B;AACD,SAJM;AAKPsB,QAAAA,GAAG,EAAE,UAAUtB,KAAV,EAAiB;AACpB,eAAKM,QAAL,CAAcD,OAAd,CAAsBL,KAAtB,GAA8BA,KAA9B;AACD;AAPM,OA9EmB;AAuF5B6B,MAAAA,OAAO,EAAE;AACPV,QAAAA,UAAU,EAAE,IADL;AAEPC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAO,KAAKd,QAAL,CAAcuB,OAAd,CAAsB7B,KAA7B;AACD,SAJM;AAKPsB,QAAAA,GAAG,EAAE,UAAUtB,KAAV,EAAiB;AACpB,eAAKM,QAAL,CAAcuB,OAAd,CAAsB7B,KAAtB,GAA8BA,KAA9B;AACD;AAPM,OAvFmB;AAgG5BE,MAAAA,UAAU,EAAE;AACViB,QAAAA,UAAU,EAAE,IADF;AAEVC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAO,KAAKd,QAAL,CAAcJ,UAAd,CAAyBF,KAAhC;AACD,SAJS;AAKVsB,QAAAA,GAAG,EAAE,UAAUtB,KAAV,EAAiB;AACpB,eAAKM,QAAL,CAAcJ,UAAd,CAAyBF,KAAzB,CAA+B8B,IAA/B,CAAoC9B,KAApC;AACD;AAPS,OAhGgB;AAyG5B+B,MAAAA,eAAe,EAAE;AACfZ,QAAAA,UAAU,EAAE,IADG;AAEfC,QAAAA,GAAG,EAAE,YAAY;AACf,iBAAOM,OAAO,CAAC,uBAAuB,KAAKH,OAA7B,CAAd;AACD,SAJc;AAKfD,QAAAA,GAAG,EAAE,UAAUtB,KAAV,EAAiB;AACpB,cAAI0B,OAAO,CAAC1B,KAAD,CAAP,KAAmB0B,OAAO,CAAC,uBAAuB,KAAKH,OAA7B,CAA9B,EAAqE;AACnE,iBAAKxE,WAAL,GAAmB,IAAnB;AACD;;AAED,cAAIiD,KAAK,KAAK,IAAd,EAAoB;AAClB,iBAAKuB,OAAL,CAAaS,iBAAb,GAAiC,EAAjC;AACA,iBAAKC,UAAL,CAAgBC,WAAhB,GAA8B,IAA9B;AACD,WAHD,MAGO;AACL,mBAAO,KAAKX,OAAL,CAAaS,iBAApB;AACA,iBAAKC,UAAL,CAAgBC,WAAhB,GAA8B,KAA9B;AACD;AACF;AAjBc;AAzGW,KAA9B;AA6HA,SAAKC,SAAL,CAAetB,UAAf;AACD;;AAxI+C;;AA4IlDD,YAAY,CAACjB,SAAb,CAAuByC,cAAvB,GAAwC,IAAxC;AAEA,MAAMzG,KAAK,GAAGD,MAAM,CAACC,KAAP,GAAeD,MAAM,CAACC,KAAtB,CAA4B;AAA5B,EACZ;AACArB,EAAAA,IADA;AAEAC,EAAAA,cAFA;AAGAG,EAAAA,0BAHA;AAIAC,EAAAA,0BAJA;AAKAS,EAAAA,KALA;AAMAC,EAAAA,SANA;AAOAC,EAAAA,OAPA;AAQAC,EAAAA,IARA;AASAX,EAAAA,MATA;AAUAC,EAAAA,OAVA;AAWAW,EAAAA;AAXA,CADF;AAeA,IAAI6G,cAAc,GAAG,IAAI1G,KAAK,CAACpB,cAAV,GAA2BsB,YAA3B,GAA0C,cAA1C,GAA2D,cAAhF;;AAEA,MAAMyG,MAAM,GAAG,IAAI3G,KAAK,CAACd,OAAV,EAAf;;AAEA,MAAM0H,IAAI,GAAG,IAAI5G,KAAK,CAACd,OAAV,EAAb;;AAEA,MAAM2H,OAAO,GAAG,IAAI7G,KAAK,CAACH,OAAV,EAAhB;;AAEA,MAAMiH,KAAK,GAAG,IAAI9G,KAAK,CAACH,OAAV,EAAd;;AAEA,MAAMkH,SAAS,GAAG,IAAI/G,KAAK,CAACH,OAAV,EAAlB;;AAEA,MAAMmH,UAAU,GAAG,IAAIhH,KAAK,CAACd,OAAV,EAAnB;;AAEA,MAAM+H,SAAS,GAAG,IAAIjH,KAAK,CAACL,OAAV,EAAlB;;AAEA,MAAMuH,KAAK,GAAG,IAAIlH,KAAK,CAACP,KAAV,EAAd;;AAEA,MAAM0H,aAAa,GAAG,IAAInH,KAAK,CAACd,OAAV,EAAtB;;AAEA,MAAMkI,IAAI,GAAG,IAAIpH,KAAK,CAACrB,IAAV,EAAb;;AAEA,MAAM0I,OAAO,GAAG,IAAIrH,KAAK,CAACf,MAAV,EAAhB;;AAEA,MAAMqI,kBAAkB,GAAG,IAAItH,KAAK,CAACH,OAAV,EAA3B;;AAEA,MAAM0H,aAAN,SAA4BvH,KAAK,CAACJ,IAAlC,CAAuC;AACrCU,EAAAA,WAAW,CAAC8B,QAAQ,GAAG,IAAI/B,oBAAJ,EAAZ,EAAwCmH,QAAQ,GAAG,IAAIvC,YAAJ,CAAiB;AAC7EM,IAAAA,KAAK,EAAEhC,IAAI,CAACkE,MAAL,KAAgB;AADsD,GAAjB,CAAnD,EAEP;AACF,UAAMrF,QAAN,EAAgBoF,QAAhB;AACA,SAAKjH,IAAL,GAAY,eAAZ;AACD,GANoC,CAMnC;;;AAGFmH,EAAAA,oBAAoB,GAAG;AACrB,UAAMtF,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAMpB,aAAa,GAAGoB,QAAQ,CAACrB,UAAT,CAAoBC,aAA1C;AACA,UAAME,WAAW,GAAGkB,QAAQ,CAACrB,UAAT,CAAoBG,WAAxC;AACA,UAAMyG,aAAa,GAAG,IAAI/F,YAAJ,CAAiB,IAAIZ,aAAa,CAACqC,KAAnC,CAAtB;;AAEA,SAAK,IAAIF,CAAC,GAAG,CAAR,EAAWyE,CAAC,GAAG,CAAf,EAAkBC,CAAC,GAAG7G,aAAa,CAACqC,KAAzC,EAAgDF,CAAC,GAAG0E,CAApD,EAAuD1E,CAAC,IAAIyE,CAAC,IAAI,CAAjE,EAAoE;AAClEjB,MAAAA,MAAM,CAACrD,mBAAP,CAA2BtC,aAA3B,EAA0CmC,CAA1C;;AAEAyD,MAAAA,IAAI,CAACtD,mBAAL,CAAyBpC,WAAzB,EAAsCiC,CAAtC;;AAEAwE,MAAAA,aAAa,CAACC,CAAD,CAAb,GAAmBA,CAAC,KAAK,CAAN,GAAU,CAAV,GAAcD,aAAa,CAACC,CAAC,GAAG,CAAL,CAA9C;AACAD,MAAAA,aAAa,CAACC,CAAC,GAAG,CAAL,CAAb,GAAuBD,aAAa,CAACC,CAAD,CAAb,GAAmBjB,MAAM,CAACmB,UAAP,CAAkBlB,IAAlB,CAA1C;AACD;;AAED,UAAMmB,sBAAsB,GAAG,IAAI/H,KAAK,CAACjB,0BAAV,CAAqC4I,aAArC,EAAoD,CAApD,EAAuD,CAAvD,CAA/B,CAfqB,CAeqE;;AAE1FvF,IAAAA,QAAQ,CAACsE,cAAD,CAAR,CAAyB,uBAAzB,EAAkD,IAAI1G,KAAK,CAAChB,0BAAV,CAAqC+I,sBAArC,EAA6D,CAA7D,EAAgE,CAAhE,CAAlD,EAjBqB,CAiBkG;;AAEvH3F,IAAAA,QAAQ,CAACsE,cAAD,CAAR,CAAyB,qBAAzB,EAAgD,IAAI1G,KAAK,CAAChB,0BAAV,CAAqC+I,sBAArC,EAA6D,CAA7D,EAAgE,CAAhE,CAAhD,EAnBqB,CAmBgG;;AAErH,WAAO,IAAP;AACD;;AAEDC,EAAAA,OAAO,CAACC,SAAD,EAAYC,UAAZ,EAAwB;AAC7B,QAAID,SAAS,CAACE,MAAV,KAAqB,IAAzB,EAA+B;AAC7BxF,MAAAA,OAAO,CAACC,KAAR,CAAc,8FAAd;AACD;;AAED,UAAMwF,SAAS,GAAGH,SAAS,CAACI,MAAV,CAAiBC,KAAjB,KAA2BnH,SAA3B,GAAuC8G,SAAS,CAACI,MAAV,CAAiBC,KAAjB,CAAuBF,SAAvB,IAAoC,CAA3E,GAA+E,CAAjG;AACA,UAAMG,GAAG,GAAGN,SAAS,CAACM,GAAtB;AACA,UAAMJ,MAAM,GAAGF,SAAS,CAACE,MAAzB;AACA,UAAMK,gBAAgB,GAAGL,MAAM,CAACK,gBAAhC;AACA,UAAMC,WAAW,GAAG,KAAKA,WAAzB;AACA,UAAMrG,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAMoF,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAMjD,UAAU,GAAGiD,QAAQ,CAACjD,UAA5B;AACA,UAAMmE,SAAS,GAAGlB,QAAQ,CAAClD,SAAT,GAAqB8D,SAAvC;AACA,UAAMpH,aAAa,GAAGoB,QAAQ,CAACrB,UAAT,CAAoBC,aAA1C;AACA,UAAME,WAAW,GAAGkB,QAAQ,CAACrB,UAAT,CAAoBG,WAAxC,CAf6B,CAewB;;AAErD,UAAMyH,IAAI,GAAG,CAACR,MAAM,CAACQ,IAArB,CAjB6B,CAiBF;AAC3B;;AAEA,UAAMC,UAAU,GAAG,MAAMrF,IAAI,CAACC,GAAL,CAASkF,SAAS,GAAGnE,UAAU,CAACsE,KAAhC,EAAuCH,SAAS,GAAGnE,UAAU,CAACuE,MAA9D,CAAzB,CApB6B,CAoBmE;AAChG;;AAEA,QAAI1G,QAAQ,CAACb,cAAT,KAA4B,IAAhC,EAAsC;AACpCa,MAAAA,QAAQ,CAACZ,qBAAT;AACD;;AAED6F,IAAAA,OAAO,CAAClB,IAAR,CAAa/D,QAAQ,CAACb,cAAtB,EAAsCX,YAAtC,CAAmD6H,WAAnD;;AAEA,UAAMM,gBAAgB,GAAGxF,IAAI,CAACC,GAAL,CAAS2E,MAAM,CAACQ,IAAhB,EAAsBtB,OAAO,CAAC2B,eAAR,CAAwBT,GAAG,CAACU,MAA5B,CAAtB,CAAzB,CA7B6B,CA6BwD;;AAErF3B,IAAAA,kBAAkB,CAAC3B,GAAnB,CAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAACoD,gBAA9B,EAAgD,GAAhD,EAAqDnI,YAArD,CAAkEuH,MAAM,CAACK,gBAAzE;;AAEAlB,IAAAA,kBAAkB,CAAC4B,cAAnB,CAAkC,MAAM5B,kBAAkB,CAAC6B,CAA3D;;AAEA7B,IAAAA,kBAAkB,CAAC1G,YAAnB,CAAgCuH,MAAM,CAACiB,uBAAvC,EAnC6B,CAmCoC;;;AAGjE,UAAMC,YAAY,GAAG9F,IAAI,CAAC+F,GAAL,CAASV,UAAU,GAAGtB,kBAAkB,CAAC6B,CAAzC,IAA8C,GAAnE;AACA9B,IAAAA,OAAO,CAAC3D,MAAR,IAAkB2F,YAAlB;;AAEA,QAAIpB,SAAS,CAACM,GAAV,CAAcgB,gBAAd,CAA+BlC,OAA/B,MAA4C,KAAhD,EAAuD;AACrD;AACD,KA3C4B,CA2C3B;AACF;;;AAGA,QAAIjF,QAAQ,CAACf,WAAT,KAAyB,IAA7B,EAAmC;AACjCe,MAAAA,QAAQ,CAACd,kBAAT;AACD;;AAED8F,IAAAA,IAAI,CAACjB,IAAL,CAAU/D,QAAQ,CAACf,WAAnB,EAAgCT,YAAhC,CAA6C6H,WAA7C;;AAEA,UAAMe,aAAa,GAAGjG,IAAI,CAACC,GAAL,CAAS2E,MAAM,CAACQ,IAAhB,EAAsBvB,IAAI,CAAC4B,eAAL,CAAqBT,GAAG,CAACU,MAAzB,CAAtB,CAAtB,CArD6B,CAqDkD;;AAE/E3B,IAAAA,kBAAkB,CAAC3B,GAAnB,CAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAAC6D,aAA9B,EAA6C,GAA7C,EAAkD5I,YAAlD,CAA+DuH,MAAM,CAACK,gBAAtE;;AAEAlB,IAAAA,kBAAkB,CAAC4B,cAAnB,CAAkC,MAAM5B,kBAAkB,CAAC6B,CAA3D;;AAEA7B,IAAAA,kBAAkB,CAAC1G,YAAnB,CAAgCuH,MAAM,CAACiB,uBAAvC,EA3D6B,CA2DoC;;;AAGjE,UAAMK,SAAS,GAAGlG,IAAI,CAAC+F,GAAL,CAASV,UAAU,GAAGtB,kBAAkB,CAAC6B,CAAzC,IAA8C,GAAhE;AACA/B,IAAAA,IAAI,CAAC5D,GAAL,CAASkG,CAAT,IAAcD,SAAd;AACArC,IAAAA,IAAI,CAAC5D,GAAL,CAASmG,CAAT,IAAcF,SAAd;AACArC,IAAAA,IAAI,CAAC5D,GAAL,CAASoG,CAAT,IAAcH,SAAd;AACArC,IAAAA,IAAI,CAACyC,GAAL,CAASH,CAAT,IAAcD,SAAd;AACArC,IAAAA,IAAI,CAACyC,GAAL,CAASF,CAAT,IAAcF,SAAd;AACArC,IAAAA,IAAI,CAACyC,GAAL,CAASD,CAAT,IAAcH,SAAd;;AAEA,QAAIxB,SAAS,CAACM,GAAV,CAAcuB,aAAd,CAA4B1C,IAA5B,MAAsC,KAA1C,EAAiD;AAC/C;AACD,KAxE4B,CAwE3B;AACF;AACA;AACA;;;AAGAmB,IAAAA,GAAG,CAACwB,EAAJ,CAAO,CAAP,EAAUhD,SAAV,EA9E6B,CA8EP;;AAEtBA,IAAAA,SAAS,CAACoC,CAAV,GAAc,CAAd;;AAEApC,IAAAA,SAAS,CAACnG,YAAV,CAAuBuH,MAAM,CAAC6B,kBAA9B;;AAEAjD,IAAAA,SAAS,CAACnG,YAAV,CAAuB4H,gBAAvB;;AAEAzB,IAAAA,SAAS,CAACmC,cAAV,CAAyB,IAAInC,SAAS,CAACoC,CAAvC,EAtF6B,CAsFc;;;AAG3CpC,IAAAA,SAAS,CAAC2C,CAAV,IAAenF,UAAU,CAACmF,CAAX,GAAe,CAA9B;AACA3C,IAAAA,SAAS,CAAC4C,CAAV,IAAepF,UAAU,CAACoF,CAAX,GAAe,CAA9B;AACA5C,IAAAA,SAAS,CAAC6C,CAAV,GAAc,CAAd;;AAEA5C,IAAAA,UAAU,CAACb,IAAX,CAAgBY,SAAhB;;AAEAE,IAAAA,SAAS,CAACgD,gBAAV,CAA2B9B,MAAM,CAAC6B,kBAAlC,EAAsDvB,WAAtD;;AAEA,SAAK,IAAItF,CAAC,GAAG,CAAR,EAAW0E,CAAC,GAAG7G,aAAa,CAACqC,KAAlC,EAAyCF,CAAC,GAAG0E,CAA7C,EAAgD1E,CAAC,EAAjD,EAAqD;AACnD0D,MAAAA,OAAO,CAACvD,mBAAR,CAA4BtC,aAA5B,EAA2CmC,CAA3C;;AAEA2D,MAAAA,KAAK,CAACxD,mBAAN,CAA0BpC,WAA1B,EAAuCiC,CAAvC;;AAEA0D,MAAAA,OAAO,CAACsC,CAAR,GAAY,CAAZ;AACArC,MAAAA,KAAK,CAACqC,CAAN,GAAU,CAAV,CANmD,CAMtC;;AAEbtC,MAAAA,OAAO,CAACjG,YAAR,CAAqBqG,SAArB;;AAEAH,MAAAA,KAAK,CAAClG,YAAN,CAAmBqG,SAAnB,EAVmD,CAUpB;;;AAG/B,UAAIiD,kBAAkB,GAAGrD,OAAO,CAAC+C,CAAR,GAAYjB,IAAZ,IAAoB7B,KAAK,CAAC8C,CAAN,GAAUjB,IAAvD;;AAEA,UAAIuB,kBAAJ,EAAwB;AACtB;AACD,OAjBkD,CAiBjD;;;AAGF,UAAIrD,OAAO,CAAC+C,CAAR,GAAYjB,IAAhB,EAAsB;AACpB,cAAMwB,SAAS,GAAGtD,OAAO,CAAC+C,CAAR,GAAY9C,KAAK,CAAC8C,CAApC;AACA,cAAMQ,CAAC,GAAG,CAACvD,OAAO,CAAC+C,CAAR,GAAYjB,IAAb,IAAqBwB,SAA/B;;AAEAtD,QAAAA,OAAO,CAACwD,IAAR,CAAavD,KAAb,EAAoBsD,CAApB;AACD,OALD,MAKO,IAAItD,KAAK,CAAC8C,CAAN,GAAUjB,IAAd,EAAoB;AACzB,cAAMwB,SAAS,GAAGrD,KAAK,CAAC8C,CAAN,GAAU/C,OAAO,CAAC+C,CAApC;AACA,cAAMQ,CAAC,GAAG,CAACtD,KAAK,CAAC8C,CAAN,GAAUjB,IAAX,IAAmBwB,SAA7B;;AAEArD,QAAAA,KAAK,CAACuD,IAAN,CAAWxD,OAAX,EAAoBuD,CAApB;AACD,OA9BkD,CA8BjD;;;AAGFvD,MAAAA,OAAO,CAACjG,YAAR,CAAqB4H,gBAArB;;AAEA1B,MAAAA,KAAK,CAAClG,YAAN,CAAmB4H,gBAAnB,EAnCmD,CAmCb;;;AAGtC3B,MAAAA,OAAO,CAACqC,cAAR,CAAuB,IAAIrC,OAAO,CAACsC,CAAnC;;AAEArC,MAAAA,KAAK,CAACoC,cAAN,CAAqB,IAAIpC,KAAK,CAACqC,CAA/B,EAxCmD,CAwChB;;;AAGnCtC,MAAAA,OAAO,CAAC6C,CAAR,IAAanF,UAAU,CAACmF,CAAX,GAAe,CAA5B;AACA7C,MAAAA,OAAO,CAAC8C,CAAR,IAAapF,UAAU,CAACoF,CAAX,GAAe,CAA5B;AACA7C,MAAAA,KAAK,CAAC4C,CAAN,IAAWnF,UAAU,CAACmF,CAAX,GAAe,CAA1B;AACA5C,MAAAA,KAAK,CAAC6C,CAAN,IAAWpF,UAAU,CAACoF,CAAX,GAAe,CAA1B,CA9CmD,CA8CtB;;AAE7BzC,MAAAA,KAAK,CAACpG,KAAN,CAAYqF,IAAZ,CAAiBU,OAAjB;;AAEAK,MAAAA,KAAK,CAACpG,KAAN,CAAY8I,CAAZ,GAAgB,CAAhB;;AAEA1C,MAAAA,KAAK,CAACjG,GAAN,CAAUkF,IAAV,CAAeW,KAAf;;AAEAI,MAAAA,KAAK,CAACjG,GAAN,CAAU2I,CAAV,GAAc,CAAd,CAtDmD,CAsDlC;;AAEjB,YAAMU,KAAK,GAAGpD,KAAK,CAACqD,4BAAN,CAAmCvD,UAAnC,EAA+C,IAA/C,CAAd;;AAEAE,MAAAA,KAAK,CAAC6C,EAAN,CAASO,KAAT,EAAgBnD,aAAhB,EA1DmD,CA0DnB;;;AAGhC,YAAMqD,IAAI,GAAGxK,KAAK,CAACN,SAAN,CAAgB2K,IAAhB,CAAqBxD,OAAO,CAAC+C,CAA7B,EAAgC9C,KAAK,CAAC8C,CAAtC,EAAyCU,KAAzC,CAAb;AACA,YAAMG,aAAa,GAAGD,IAAI,IAAI,CAAC,CAAT,IAAcA,IAAI,IAAI,CAA5C;AACA,YAAME,QAAQ,GAAG1D,UAAU,CAACc,UAAX,CAAsBX,aAAtB,IAAuCuB,SAAS,GAAG,GAApE;;AAEA,UAAI+B,aAAa,IAAIC,QAArB,EAA+B;AAC7BxD,QAAAA,KAAK,CAACpG,KAAN,CAAYwC,mBAAZ,CAAgCtC,aAAhC,EAA+CmC,CAA/C;;AAEA+D,QAAAA,KAAK,CAACjG,GAAN,CAAUqC,mBAAV,CAA8BpC,WAA9B,EAA2CiC,CAA3C;;AAEA+D,QAAAA,KAAK,CAACpG,KAAN,CAAYF,YAAZ,CAAyB6H,WAAzB;;AAEAvB,QAAAA,KAAK,CAACjG,GAAN,CAAUL,YAAV,CAAuB6H,WAAvB;;AAEA,cAAMkC,WAAW,GAAG,IAAI3K,KAAK,CAACd,OAAV,EAApB;AACA,cAAM0L,KAAK,GAAG,IAAI5K,KAAK,CAACd,OAAV,EAAd;AACAqJ,QAAAA,GAAG,CAACsC,mBAAJ,CAAwB3D,KAAK,CAACpG,KAA9B,EAAqCoG,KAAK,CAACjG,GAA3C,EAAgD2J,KAAhD,EAAuDD,WAAvD;AACAzC,QAAAA,UAAU,CAAC4C,IAAX,CAAgB;AACdF,UAAAA,KAAK,EAAEA,KADO;AAEdD,UAAAA,WAAW,EAAEA,WAFC;AAGdI,UAAAA,QAAQ,EAAExC,GAAG,CAACU,MAAJ,CAAWnB,UAAX,CAAsB8C,KAAtB,CAHI;AAIdI,UAAAA,MAAM,EAAE,IAJM;AAKdC,UAAAA,IAAI,EAAE,IALQ;AAMdC,UAAAA,SAAS,EAAE/H,CANG;AAOdgI,UAAAA,EAAE,EAAE,IAPU;AAQdC,UAAAA,GAAG,EAAE;AARS,SAAhB;AAUD;AACF;AACF;;AA3NoC;;AA+NvC7D,aAAa,CAACvD,SAAd,CAAwBuD,aAAxB,GAAwC,IAAxC;;AAEA,MAAM8D,YAAN,SAA2BhL,oBAA3B,CAAgD;AAC9CC,EAAAA,WAAW,GAAG;AACZ;AACA,SAAKC,IAAL,GAAY,cAAZ;AACD;;AAEDkB,EAAAA,YAAY,CAACC,KAAD,EAAQ;AAClB;AACA,QAAI4J,MAAM,GAAG5J,KAAK,CAAC4J,MAAN,GAAe,CAA5B;AACA,QAAIC,MAAM,GAAG,IAAI3J,YAAJ,CAAiB,IAAI0J,MAArB,CAAb;;AAEA,SAAK,IAAInI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmI,MAApB,EAA4BnI,CAAC,IAAI,CAAjC,EAAoC;AAClCoI,MAAAA,MAAM,CAAC,IAAIpI,CAAL,CAAN,GAAgBzB,KAAK,CAACyB,CAAD,CAArB;AACAoI,MAAAA,MAAM,CAAC,IAAIpI,CAAJ,GAAQ,CAAT,CAAN,GAAoBzB,KAAK,CAACyB,CAAC,GAAG,CAAL,CAAzB;AACAoI,MAAAA,MAAM,CAAC,IAAIpI,CAAJ,GAAQ,CAAT,CAAN,GAAoBzB,KAAK,CAACyB,CAAC,GAAG,CAAL,CAAzB;AACAoI,MAAAA,MAAM,CAAC,IAAIpI,CAAJ,GAAQ,CAAT,CAAN,GAAoBzB,KAAK,CAACyB,CAAC,GAAG,CAAL,CAAzB;AACAoI,MAAAA,MAAM,CAAC,IAAIpI,CAAJ,GAAQ,CAAT,CAAN,GAAoBzB,KAAK,CAACyB,CAAC,GAAG,CAAL,CAAzB;AACAoI,MAAAA,MAAM,CAAC,IAAIpI,CAAJ,GAAQ,CAAT,CAAN,GAAoBzB,KAAK,CAACyB,CAAC,GAAG,CAAL,CAAzB;AACD;;AAED,UAAM1B,YAAN,CAAmB8J,MAAnB;AACA,WAAO,IAAP;AACD;;AAEDvJ,EAAAA,SAAS,CAACN,KAAD,EAAQ;AACf;AACA,QAAI4J,MAAM,GAAG5J,KAAK,CAAC4J,MAAN,GAAe,CAA5B;AACA,QAAIrJ,MAAM,GAAG,IAAIL,YAAJ,CAAiB,IAAI0J,MAArB,CAAb;;AAEA,SAAK,IAAInI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmI,MAApB,EAA4BnI,CAAC,IAAI,CAAjC,EAAoC;AAClClB,MAAAA,MAAM,CAAC,IAAIkB,CAAL,CAAN,GAAgBzB,KAAK,CAACyB,CAAD,CAArB;AACAlB,MAAAA,MAAM,CAAC,IAAIkB,CAAJ,GAAQ,CAAT,CAAN,GAAoBzB,KAAK,CAACyB,CAAC,GAAG,CAAL,CAAzB;AACAlB,MAAAA,MAAM,CAAC,IAAIkB,CAAJ,GAAQ,CAAT,CAAN,GAAoBzB,KAAK,CAACyB,CAAC,GAAG,CAAL,CAAzB;AACAlB,MAAAA,MAAM,CAAC,IAAIkB,CAAJ,GAAQ,CAAT,CAAN,GAAoBzB,KAAK,CAACyB,CAAC,GAAG,CAAL,CAAzB;AACAlB,MAAAA,MAAM,CAAC,IAAIkB,CAAJ,GAAQ,CAAT,CAAN,GAAoBzB,KAAK,CAACyB,CAAC,GAAG,CAAL,CAAzB;AACAlB,MAAAA,MAAM,CAAC,IAAIkB,CAAJ,GAAQ,CAAT,CAAN,GAAoBzB,KAAK,CAACyB,CAAC,GAAG,CAAL,CAAzB;AACD;;AAED,UAAMnB,SAAN,CAAgBC,MAAhB;AACA,WAAO,IAAP;AACD;;AAEDuJ,EAAAA,QAAQ,CAACrH,IAAD,EAAO;AACb,QAAI/B,QAAQ,GAAG+B,IAAI,CAAC/B,QAApB;;AAEA,QAAIA,QAAQ,CAACM,UAAb,EAAyB;AACvBC,MAAAA,OAAO,CAACC,KAAR,CAAc,mFAAd;AACA;AACD,KAHD,MAGO,IAAIR,QAAQ,CAACS,gBAAb,EAA+B;AACpC,WAAKpB,YAAL,CAAkBW,QAAQ,CAACrB,UAAT,CAAoBsB,QAApB,CAA6BX,KAA/C,EADoC,CACmB;AACxD,KARY,CAQX;;;AAGF,WAAO,IAAP;AACD;;AAtD6C;;AA0DhD2J,YAAY,CAACrH,SAAb,CAAuByH,cAAvB,GAAwC,IAAxC;;AAEA,MAAMnD,KAAN,SAAoBf,aAApB,CAAkC;AAChCjH,EAAAA,WAAW,CAAC8B,QAAQ,GAAG,IAAIiJ,YAAJ,EAAZ,EAAgC7D,QAAQ,GAAG,IAAIvC,YAAJ,CAAiB;AACrEM,IAAAA,KAAK,EAAEhC,IAAI,CAACkE,MAAL,KAAgB;AAD8C,GAAjB,CAA3C,EAEP;AACF,UAAMrF,QAAN,EAAgBoF,QAAhB;AACA,SAAKjH,IAAL,GAAY,OAAZ;AACD;;AAN+B;;AAUlC+H,KAAK,CAACtE,SAAN,CAAgB0H,OAAhB,GAA0B,IAA1B;AAEA,SAASpD,KAAT,EAAgB+C,YAAhB,EAA8BpG,YAA9B,EAA4CsC,aAA5C,EAA2DlH,oBAA3D","sourcesContent":["import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Vector2, Line3, MathUtils, Matrix4, Mesh, Vector4 } from 'three';\n\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n}; // support multiple method names for backwards threejs compatibility\n\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _box$1 = new THREE$2.Box3();\n\nconst _vector = new THREE$2.Vector3();\n\nclass LineSegmentsGeometry extends THREE$2.InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.type = 'LineSegmentsGeometry';\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this[setAttributeFn$1]('position', new THREE$2.Float32BufferAttribute(positions, 3));\n    this[setAttributeFn$1]('uv', new THREE$2.Float32BufferAttribute(uvs, 2));\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  setPositions(array) {\n    let lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    const instanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn$1]('instanceStart', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn$1]('instanceEnd', new THREE$2.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n\n  setColors(array) {\n    let colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    const instanceColorBuffer = new THREE$2.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn$1]('instanceColorStart', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn$1]('instanceColorEnd', new THREE$2.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new THREE$2.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new THREE$2.Box3();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n\n      _box$1.setFromBufferAttribute(end);\n\n      this.boundingBox.union(_box$1);\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new THREE$2.Sphere();\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n\n        _vector.fromBufferAttribute(end, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n\n  toJSON() {// todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n}\n\nLineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  worldUnits: {\n    value: 1\n  },\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new THREE$1.Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  gapSize: {\n    value: 1\n  } // todo FIX - maybe change to totalSize\n\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\tworldStart = start.xyz;\n\t\t\tworldEnd = end.xyz;\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segements overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\t\tvarying vec4 worldPos;\n\t\tvarying vec3 worldStart;\n\t\tvarying vec3 worldEnd;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends THREE$1.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n      uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n      vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n      fragmentShader: THREE$1.ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      worldUnits: {\n        enumerable: true,\n        get: function () {\n          return 'WORLD_UNITS' in this.defines;\n        },\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = '';\n          } else {\n            delete this.defines.WORLD_UNITS;\n          }\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value === true) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value === true) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nLineMaterial.prototype.isLineMaterial = true;\n\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4\n};\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nconst _start = new THREE.Vector3();\n\nconst _end = new THREE.Vector3();\n\nconst _start4 = new THREE.Vector4();\n\nconst _end4 = new THREE.Vector4();\n\nconst _ssOrigin = new THREE.Vector4();\n\nconst _ssOrigin3 = new THREE.Vector3();\n\nconst _mvMatrix = new THREE.Matrix4();\n\nconst _line = new THREE.Line3();\n\nconst _closestPoint = new THREE.Vector3();\n\nconst _box = new THREE.Box3();\n\nconst _sphere = new THREE.Sphere();\n\nconst _clipToWorldVector = new THREE.Vector4();\n\nclass LineSegments2 extends THREE.Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'LineSegments2';\n  } // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry[setAttributeFn]('instanceDistanceStart', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry[setAttributeFn]('instanceDistanceEnd', new THREE.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    const ray = raycaster.ray;\n    const camera = raycaster.camera;\n    const projectionMatrix = camera.projectionMatrix;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    const resolution = material.resolution;\n    const lineWidth = material.linewidth + threshold;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n    const near = -camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full\n    // width in clip space\n\n    const ssMaxWidth = 2.0 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height); //\n    // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n\n    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToSphere, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _sphere.radius += sphereMargin;\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) {\n      return;\n    } //\n    // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n\n    const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // get the w component to scale the world space line width\n\n    _clipToWorldVector.set(0, 0, -distanceToBox, 1.0).applyMatrix4(camera.projectionMatrix);\n\n    _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n    _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse); // increase the sphere bounds by the worst case line screen space width\n\n\n    const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;\n    _box.max.x += boxMargin;\n    _box.max.y += boxMargin;\n    _box.max.z += boxMargin;\n    _box.min.x -= boxMargin;\n    _box.min.y -= boxMargin;\n    _box.min.z -= boxMargin;\n\n    if (raycaster.ray.intersectsBox(_box) === false) {\n      return;\n    } //\n    // pick a point 1 unit out along the ray to avoid the ray origin\n    // sitting at the camera origin which will cause \"w\" to be 0 when\n    // applying the projection matrix.\n\n\n    ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n    _ssOrigin.w = 1;\n\n    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n    _ssOrigin.applyMatrix4(projectionMatrix);\n\n    _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n    _ssOrigin.x *= resolution.x / 2;\n    _ssOrigin.y *= resolution.y / 2;\n    _ssOrigin.z = 0;\n\n    _ssOrigin3.copy(_ssOrigin);\n\n    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n    for (let i = 0, l = instanceStart.count; i < l; i++) {\n      _start4.fromBufferAttribute(instanceStart, i);\n\n      _end4.fromBufferAttribute(instanceEnd, i);\n\n      _start4.w = 1;\n      _end4.w = 1; // camera space\n\n      _start4.applyMatrix4(_mvMatrix);\n\n      _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n      var isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n      if (isBehindCameraNear) {\n        continue;\n      } // trim the segment if it extends behind camera near\n\n\n      if (_start4.z > near) {\n        const deltaDist = _start4.z - _end4.z;\n        const t = (_start4.z - near) / deltaDist;\n\n        _start4.lerp(_end4, t);\n      } else if (_end4.z > near) {\n        const deltaDist = _end4.z - _start4.z;\n        const t = (_end4.z - near) / deltaDist;\n\n        _end4.lerp(_start4, t);\n      } // clip space\n\n\n      _start4.applyMatrix4(projectionMatrix);\n\n      _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n      _start4.multiplyScalar(1 / _start4.w);\n\n      _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n      _start4.x *= resolution.x / 2;\n      _start4.y *= resolution.y / 2;\n      _end4.x *= resolution.x / 2;\n      _end4.y *= resolution.y / 2; // create 2d segment\n\n      _line.start.copy(_start4);\n\n      _line.start.z = 0;\n\n      _line.end.copy(_end4);\n\n      _line.end.z = 0; // get closest point on ray to segment\n\n      const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n      _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n      const zPos = THREE.MathUtils.lerp(_start4.z, _end4.z, param);\n      const isInClipSpace = zPos >= -1 && zPos <= 1;\n      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n\n      if (isInClipSpace && isInside) {\n        _line.start.fromBufferAttribute(instanceStart, i);\n\n        _line.end.fromBufferAttribute(instanceEnd, i);\n\n        _line.start.applyMatrix4(matrixWorld);\n\n        _line.end.applyMatrix4(matrixWorld);\n\n        const pointOnLine = new THREE.Vector3();\n        const point = new THREE.Vector3();\n        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n        intersects.push({\n          point: point,\n          pointOnLine: pointOnLine,\n          distance: ray.origin.distanceTo(point),\n          object: this,\n          face: null,\n          faceIndex: i,\n          uv: null,\n          uv2: null\n        });\n      }\n    }\n  }\n\n}\n\nLineSegments2.prototype.LineSegments2 = true;\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super();\n    this.type = 'LineGeometry';\n  }\n\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    super.setPositions(points);\n    return this;\n  }\n\n  setColors(array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n\n    super.setColors(colors);\n    return this;\n  }\n\n  fromLine(line) {\n    var geometry = line.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  }\n\n}\n\nLineGeometry.prototype.isLineGeometry = true;\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'Line2';\n  }\n\n}\n\nLine2.prototype.isLine2 = true;\n\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };\n"]},"metadata":{},"sourceType":"module"}