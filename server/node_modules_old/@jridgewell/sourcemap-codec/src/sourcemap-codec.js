"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = exports.decode = exports.encodeGeneratedRanges = exports.decodeGeneratedRanges = exports.encodeOriginalScopes = exports.decodeOriginalScopes = void 0;
const vlq_1 = require("./vlq");
const strings_1 = require("./strings");
var scopes_1 = require("./scopes");
Object.defineProperty(exports, "decodeOriginalScopes", { enumerable: true, get: function () { return scopes_1.decodeOriginalScopes; } });
Object.defineProperty(exports, "encodeOriginalScopes", { enumerable: true, get: function () { return scopes_1.encodeOriginalScopes; } });
Object.defineProperty(exports, "decodeGeneratedRanges", { enumerable: true, get: function () { return scopes_1.decodeGeneratedRanges; } });
Object.defineProperty(exports, "encodeGeneratedRanges", { enumerable: true, get: function () { return scopes_1.encodeGeneratedRanges; } });
function decode(mappings) {
    const { length } = mappings;
    const reader = new strings_1.StringReader(mappings);
    const decoded = [];
    let genColumn = 0;
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    do {
        const semi = reader.indexOf(';');
        const line = [];
        let sorted = true;
        let lastCol = 0;
        genColumn = 0;
        while (reader.pos < semi) {
            let seg;
            genColumn = (0, vlq_1.decodeInteger)(reader, genColumn);
            if (genColumn < lastCol)
                sorted = false;
            lastCol = genColumn;
            if ((0, vlq_1.hasMoreVlq)(reader, semi)) {
                sourcesIndex = (0, vlq_1.decodeInteger)(reader, sourcesIndex);
                sourceLine = (0, vlq_1.decodeInteger)(reader, sourceLine);
                sourceColumn = (0, vlq_1.decodeInteger)(reader, sourceColumn);
                if ((0, vlq_1.hasMoreVlq)(reader, semi)) {
                    namesIndex = (0, vlq_1.decodeInteger)(reader, namesIndex);
                    seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
                }
                else {
                    seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
                }
            }
            else {
                seg = [genColumn];
            }
            line.push(seg);
            reader.pos++;
        }
        if (!sorted)
            sort(line);
        decoded.push(line);
        reader.pos = semi + 1;
    } while (reader.pos <= length);
    return decoded;
}
exports.decode = decode;
function sort(line) {
    line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[0] - b[0];
}
function encode(decoded) {
    const writer = new strings_1.StringWriter();
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    for (let i = 0; i < decoded.length; i++) {
        const line = decoded[i];
        if (i > 0)
            writer.write(vlq_1.semicolon);
        if (line.length === 0)
            continue;
        let genColumn = 0;
        for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0)
                writer.write(vlq_1.comma);
            genColumn = (0, vlq_1.encodeInteger)(writer, segment[0], genColumn);
            if (segment.length === 1)
                continue;
            sourcesIndex = (0, vlq_1.encodeInteger)(writer, segment[1], sourcesIndex);
            sourceLine = (0, vlq_1.encodeInteger)(writer, segment[2], sourceLine);
            sourceColumn = (0, vlq_1.encodeInteger)(writer, segment[3], sourceColumn);
            if (segment.length === 4)
                continue;
            namesIndex = (0, vlq_1.encodeInteger)(writer, segment[4], namesIndex);
        }
    }
    return writer.flush();
}
exports.encode = encode;
