"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeGeneratedRanges = exports.decodeGeneratedRanges = exports.encodeOriginalScopes = exports.decodeOriginalScopes = void 0;
const strings_1 = require("./strings");
const vlq_1 = require("./vlq");
const EMPTY = [];
function decodeOriginalScopes(input) {
    const { length } = input;
    const reader = new strings_1.StringReader(input);
    const scopes = [];
    const stack = [];
    let line = 0;
    for (; reader.pos < length; reader.pos++) {
        line = (0, vlq_1.decodeInteger)(reader, line);
        const column = (0, vlq_1.decodeInteger)(reader, 0);
        if (!(0, vlq_1.hasMoreVlq)(reader, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
        }
        const kind = (0, vlq_1.decodeInteger)(reader, 0);
        const fields = (0, vlq_1.decodeInteger)(reader, 0);
        const hasName = fields & 0b0001;
        const scope = (hasName ? [line, column, 0, 0, kind, (0, vlq_1.decodeInteger)(reader, 0)] : [line, column, 0, 0, kind]);
        let vars = EMPTY;
        if ((0, vlq_1.hasMoreVlq)(reader, length)) {
            vars = [];
            do {
                const varsIndex = (0, vlq_1.decodeInteger)(reader, 0);
                vars.push(varsIndex);
            } while ((0, vlq_1.hasMoreVlq)(reader, length));
        }
        scope.vars = vars;
        scopes.push(scope);
        stack.push(scope);
    }
    return scopes;
}
exports.decodeOriginalScopes = decodeOriginalScopes;
function encodeOriginalScopes(scopes) {
    const writer = new strings_1.StringWriter();
    for (let i = 0; i < scopes.length;) {
        i = _encodeOriginalScopes(scopes, i, writer, [0]);
    }
    return writer.flush();
}
exports.encodeOriginalScopes = encodeOriginalScopes;
function _encodeOriginalScopes(scopes, index, writer, state) {
    const scope = scopes[index];
    const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
    if (index > 0)
        writer.write(vlq_1.comma);
    state[0] = (0, vlq_1.encodeInteger)(writer, startLine, state[0]);
    (0, vlq_1.encodeInteger)(writer, startColumn, 0);
    (0, vlq_1.encodeInteger)(writer, kind, 0);
    const fields = scope.length === 6 ? 0b0001 : 0;
    (0, vlq_1.encodeInteger)(writer, fields, 0);
    if (scope.length === 6)
        (0, vlq_1.encodeInteger)(writer, scope[5], 0);
    for (const v of vars) {
        (0, vlq_1.encodeInteger)(writer, v, 0);
    }
    for (index++; index < scopes.length;) {
        const next = scopes[index];
        const { 0: l, 1: c } = next;
        if (l > endLine || (l === endLine && c >= endColumn)) {
            break;
        }
        index = _encodeOriginalScopes(scopes, index, writer, state);
    }
    writer.write(vlq_1.comma);
    state[0] = (0, vlq_1.encodeInteger)(writer, endLine, state[0]);
    (0, vlq_1.encodeInteger)(writer, endColumn, 0);
    return index;
}
function decodeGeneratedRanges(input) {
    const { length } = input;
    const reader = new strings_1.StringReader(input);
    const ranges = [];
    const stack = [];
    let genLine = 0;
    let definitionSourcesIndex = 0;
    let definitionScopeIndex = 0;
    let callsiteSourcesIndex = 0;
    let callsiteLine = 0;
    let callsiteColumn = 0;
    let bindingLine = 0;
    let bindingColumn = 0;
    do {
        const semi = reader.indexOf(';');
        let genColumn = 0;
        for (; reader.pos < semi; reader.pos++) {
            genColumn = (0, vlq_1.decodeInteger)(reader, genColumn);
            if (!(0, vlq_1.hasMoreVlq)(reader, semi)) {
                const last = stack.pop();
                last[2] = genLine;
                last[3] = genColumn;
                continue;
            }
            const fields = (0, vlq_1.decodeInteger)(reader, 0);
            const hasDefinition = fields & 0b0001;
            const hasCallsite = fields & 0b0010;
            const hasScope = fields & 0b0100;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
                const defSourcesIndex = (0, vlq_1.decodeInteger)(reader, definitionSourcesIndex);
                definitionScopeIndex = (0, vlq_1.decodeInteger)(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
                definitionSourcesIndex = defSourcesIndex;
                range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            }
            else {
                range = [genLine, genColumn, 0, 0];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
                const prevCsi = callsiteSourcesIndex;
                const prevLine = callsiteLine;
                callsiteSourcesIndex = (0, vlq_1.decodeInteger)(reader, callsiteSourcesIndex);
                const sameSource = prevCsi === callsiteSourcesIndex;
                callsiteLine = (0, vlq_1.decodeInteger)(reader, sameSource ? callsiteLine : 0);
                callsiteColumn = (0, vlq_1.decodeInteger)(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
                callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range.callsite = callsite;
            if ((0, vlq_1.hasMoreVlq)(reader, semi)) {
                bindings = [];
                do {
                    bindingLine = genLine;
                    bindingColumn = genColumn;
                    const expressionsCount = (0, vlq_1.decodeInteger)(reader, 0);
                    let expressionRanges;
                    if (expressionsCount < -1) {
                        expressionRanges = [[(0, vlq_1.decodeInteger)(reader, 0)]];
                        for (let i = -1; i > expressionsCount; i--) {
                            const prevBl = bindingLine;
                            bindingLine = (0, vlq_1.decodeInteger)(reader, bindingLine);
                            bindingColumn = (0, vlq_1.decodeInteger)(reader, bindingLine === prevBl ? bindingColumn : 0);
                            const expression = (0, vlq_1.decodeInteger)(reader, 0);
                            expressionRanges.push([expression, bindingLine, bindingColumn]);
                        }
                    }
                    else {
                        expressionRanges = [[expressionsCount]];
                    }
                    bindings.push(expressionRanges);
                } while ((0, vlq_1.hasMoreVlq)(reader, semi));
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
        }
        genLine++;
        reader.pos = semi + 1;
    } while (reader.pos < length);
    return ranges;
}
exports.decodeGeneratedRanges = decodeGeneratedRanges;
function encodeGeneratedRanges(ranges) {
    if (ranges.length === 0)
        return '';
    const writer = new strings_1.StringWriter();
    for (let i = 0; i < ranges.length;) {
        i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
    }
    return writer.flush();
}
exports.encodeGeneratedRanges = encodeGeneratedRanges;
function _encodeGeneratedRanges(ranges, index, writer, state) {
    const range = ranges[index];
    const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings, } = range;
    if (state[0] < startLine) {
        catchupLine(writer, state[0], startLine);
        state[0] = startLine;
        state[1] = 0;
    }
    else if (index > 0) {
        writer.write(vlq_1.comma);
    }
    state[1] = (0, vlq_1.encodeInteger)(writer, range[1], state[1]);
    const fields = (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);
    (0, vlq_1.encodeInteger)(writer, fields, 0);
    if (range.length === 6) {
        const { 4: sourcesIndex, 5: scopesIndex } = range;
        if (sourcesIndex !== state[2]) {
            state[3] = 0;
        }
        state[2] = (0, vlq_1.encodeInteger)(writer, sourcesIndex, state[2]);
        state[3] = (0, vlq_1.encodeInteger)(writer, scopesIndex, state[3]);
    }
    if (callsite) {
        const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
        if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
        }
        else if (callLine !== state[5]) {
            state[6] = 0;
        }
        state[4] = (0, vlq_1.encodeInteger)(writer, sourcesIndex, state[4]);
        state[5] = (0, vlq_1.encodeInteger)(writer, callLine, state[5]);
        state[6] = (0, vlq_1.encodeInteger)(writer, callColumn, state[6]);
    }
    if (bindings) {
        for (const binding of bindings) {
            if (binding.length > 1)
                (0, vlq_1.encodeInteger)(writer, -binding.length, 0);
            const expression = binding[0][0];
            (0, vlq_1.encodeInteger)(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for (let i = 1; i < binding.length; i++) {
                const expRange = binding[i];
                bindingStartLine = (0, vlq_1.encodeInteger)(writer, expRange[1], bindingStartLine);
                bindingStartColumn = (0, vlq_1.encodeInteger)(writer, expRange[2], bindingStartColumn);
                (0, vlq_1.encodeInteger)(writer, expRange[0], 0);
            }
        }
    }
    for (index++; index < ranges.length;) {
        const next = ranges[index];
        const { 0: l, 1: c } = next;
        if (l > endLine || (l === endLine && c >= endColumn)) {
            break;
        }
        index = _encodeGeneratedRanges(ranges, index, writer, state);
    }
    if (state[0] < endLine) {
        catchupLine(writer, state[0], endLine);
        state[0] = endLine;
        state[1] = 0;
    }
    else {
        writer.write(vlq_1.comma);
    }
    state[1] = (0, vlq_1.encodeInteger)(writer, endColumn, state[1]);
    return index;
}
function catchupLine(writer, lastLine, line) {
    do {
        writer.write(vlq_1.semicolon);
    } while (++lastLine < line);
}
